{"name":"Yagalib","body":"yagalib\r\n=======\r\n\r\nYet Another Genetic Algorithm library - A simple set of Java interfaces and classes to build GA applications\r\n\r\nOverview\r\n========\r\n\r\nyagalib is a set of interfaces for 4 key operators in a genetic algorithm (GA) framework: Environments, Organisms,\r\nGenomes and Genes.  The library also provides an EvolutionManager class that executes all of the evolutionary\r\nlogic against the Environment.\r\n\r\nBuilding\r\n========\r\n\r\nyagalib uses Maven for dependency management and building, so you will need a working Maven setup on your box.  To\r\nbuild, just do \"mvn install\" in the project root.  This will install the resulting jar in your maven repo.\r\n\r\nUsage\r\n=====\r\n\r\nThe first step to using yagalib for your GA application is to identify the entities representing the 4 interfaces in\r\nyour project.\r\n\r\n- Environment: The Environment is the world in which the entities you are trying to evolve operate within.  In the\r\nexample project included in the yagalib_example module, the class implementing Environment is the Casino class.  The\r\nCasino class includes all the necessary logic and objects to exercise the blackjack-playing Agents that live within\r\nit.  Another example might be a stock market floor.  Environments can also be something more abstract; they exist\r\nfor the purpose of aggregating Organisms and forcing each one to exercise its Genes.  Whichever class in your model\r\nhandles those functions is a good candidate for implementing the Environment interface.\r\n\r\n- Organism: The Organisms are the entities you are trying to evolve to higher levels of fitness.  In the example\r\nprovided, the Agent class implements Organism as a blackjack player in a casino.  In a stock market example, the\r\nOrganisms might be stock traders.  More abstract Organisms might be things like equations in a line fitting application.\r\nImportantly, the Organism class is where you implement your crucial fitness function, getFitness().  This means that\r\neach Organism must be able to evaluate its own fitness.\r\n\r\n- Genome: Each Organism stores its genetic code in a Genome.  A Genome is a collection of Genes, and represent the\r\n\"ruleset\" each Organism follows in order to make decisions within the Environment.  In the included blackjack example,\r\nthe Strategy class implements the Genome interface.  Other examples might be the list of rules a stock broker uses\r\nto buy or sell stocks, etc.  The Genome is responsible for carrying out the Crossover, Complexify and Simplify\r\ngenetic operations.\r\n\r\n- Gene: Finally, Genes represent the individual rules your Organisms use to make decisions and act in the Environment.\r\nGenes implement the Mutation genetic operation, so you need to make sure that your implementing class is able to\r\nrepresent its logic as discrete parts of a whole.  A good example from the blackjack example project is the Rule class.\r\nEach Rule is made up of 5 parts: the dealer's up card, the value of the player's hand, whether the hand is hard or soft,\r\nwhether the hand is splittable, and finally the command to execute.  When an Agent is prompted for input from the\r\nDealer, it uses the current up card and its hand to find a Rule in its Genome that matches.  If it finds one, it tells\r\nthe Dealer the associated command, which the Dealer executes.  With this encoding of the blackjack player's logic,\r\nmutations are straightforward: choose one of the 5 parts (call them \"base pairs\" I guess?) of the Gene and change its\r\nvalue to a random, valid value.\r\n\r\nOnce you have identified and implemented each of the 4 interfaces in your model, the next step is to instantiate an\r\nEvolutionManager object, set its various rates, and tell it to evolve your Organisms.  The various rates that affect\r\nthe pace and efficacy of evolution are:\r\n\r\n- Death Rate: how many of the least fit Organisms get culled from the herd each generation, per thousand.\r\n- Birth Rate: how many of the surviving Organisms get to breed offspring each generation, per thousand.\r\n- Mutation Rate: how many of the surviving Organisms undergo a point mutation each generation, per thousand.\r\n- Complexify Rate: how many surviving Organisms spontaneously comlexify their Genomes each generation, per thousand.\r\n- Simplify Rate: how many surviving Organisms spontaneously simplify their Genomes each generatoin, per thousand.\r\n\r\nThe included blackjack example contains a test case, GABlackJackTest, that illustrates how to setup and execute a run:\r\n\r\n>        EvolutionManager em = new EvolutionManager();\r\n>        em.setPopulation(100);\r\n>        em.setBirthRatePerThousand(500);\r\n>        em.setDeathRatePerThousand(500);\r\n>        em.setMutationChancePerThousand(500);\r\n>        em.setComplexifyChancePerThousand(500);\r\n>        em.setSimplifyChancePerThousand(0);\r\n>        em.setEnvironment(new Casino());\r\n>        em.setupEnvironment();\r\n>        FileStatWriter writer = new FileStatWriter(\"/tmp/genstats\");\r\n>        writer.init();\r\n>        em.setWriter(writer);\r\n>        em.evolve(100);\r\n\r\nTL;DR\r\n=====\r\n\r\nClone the project, find and execute the GABlackJackTest.  Watch the median fitness of the blackjack players grow.\r\n","tagline":"Yet Another Genetic Algorithm library - A simple set of Java interfaces and classes to build GA applications","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}